import helpers { read_lines, min }

class Valve {
    name: String
    rate: i64? = None
    tunnels: [String]
    tunnel_weights: [String: i64]

    public function set_distance(mut this, anon s: String, anon i: i64) throws {
        this.tunnel_weights.set(s, i)
    }

    public function immediate_tunnels(this) -> [String] {
        return this.tunnels
    }

    public function flow_rate(this) -> i64 {
        return this.rate!
    }

    public function neighbours(this) -> [String: i64] {
        // TODO change this to have weights to all other nodes?
        // so we can move all the way to the right place
        // this will be useful in calculating the h()
        return this.tunnel_weights // FIXME this may allow modification
    }

    public function parse(mut valves: [String: Valve?], anon s: String) throws -> Valve {
        let split = s.split(' ')
        let name = split[1]
        let rate = split[4].split('=')[1].split(';')[0].to_int()! as! i64
        // paths start at [9]
        mut tunnels: [String] = []

        for i in 9..split.size() {
            let v_name = split[i].split(',')[0]
            tunnels.push(v_name)
        }

        let tunnel_weights: [String: i64] = Dictionary<String, i64>()
        let valve = Some(Valve(name, rate, tunnels, tunnel_weights))
        valves.set(name, valve)
        return valve!
    }
}

struct Node {
    current: String? = None
    current_e: String? = None
    minutes: i64 = 0
    open_valves: [String]
    released: i64 = 0
    just_opened: String? = None
    just_opened_e: String? = None
    minutes_left: i64 = 0
    minutes_left_e: i64 = 0

    function start_node() throws -> Node {
        let open_valves: [String] = []
        return Node(current: "AA", current_e: "AA", open_valves)
    }

    function clone(this) throws -> Node {
        mut open_valves: [String] = []
        for v in this.open_valves {
            open_valves.push(v)
        }
        return Node(
            current: this.current,
            current_e: this.current_e,
            minutes: this.minutes,
            open_valves,
            released: this.released,
        )
    }

    function neighbours(this, valves: [String: Valve?], elephant: bool=false) throws -> [Node] {
        mut ret: [Node] = []
        if elephant and this.minutes == 0 {
            mut node = this.clone()
            // teach the elephant how to do things
            node.minutes += 4
            ret.push(node)
            return ret
        }
        if elephant {
            // FIXME:
            // we currently have mirrored node paths
            // it doesn't matter if we do one valve and the elephant the other or vice versa
            if this.minutes_left > 0 {
                // pick another one for the elephant, get min and set either minutes_left or minutes_left_e
                let s = this.current!
                mut time = this.minutes_left
                let valve_e = valves.get(this.current_e!)!!
                for (s_e, i_e) in valve_e.neighbours() {
                    if s == s_e { continue }
                    if s_e == this.current_e! { continue }
                    if this.open_valves.contains(s_e) { continue }
                    if valves.get(s_e)!!.flow_rate() == 0 { continue }
                    time = this.minutes_left
                    mut time_e = i_e + 1 // travel time + open time
                    mut node = this.clone()
                    node.current_e = s_e
                    if time_e > time {
                        // we can get all the way to our valve, the elephant won't
                        time_e -= time
                        node.minutes += time
                        node.minutes_left = 0
                        node.minutes_left_e = time_e // set time remaining for elephant
                        for v2 in node.open_valves {
                            node.released += time * valves.get(v2)!!.flow_rate()
                        }
                        // open it
                        node.open_valves.push(node.current!)
                        node.just_opened = node.current!
                        ret.push(node)
                    } else {
                        // we either get to our goal at same time as elephant, or elephant beats us
                        time -= time_e
                        node.minutes += time_e
                        node.minutes_left = time // this may be 0 if we get there at same time
                        node.minutes_left_e = 0
                        for v2 in node.open_valves {
                            node.released += time_e * valves.get(v2)!!.flow_rate()
                        }
                        // open it
                        if time == 0 {
                            node.open_valves.push(node.current!)
                            node.just_opened = node.current!
                        }
                        node.open_valves.push(node.current_e!)
                        node.just_opened_e = node.current_e!
                        ret.push(node)
                    }
                }
                if ret.size() == 0 {
                    mut node = this.clone()
                    time = this.minutes_left
                    if time > this.minutes_remaining() {
                        // should be unreachable with check above
                        eprintln("unreachable time > this.minutes_remaining() ({} > {}) - {}", time, this.minutes_remaining(), this)
                        return ret
                    }
                    node.minutes += time
                    node.minutes_left = 0
                    for v2 in node.open_valves {
                        node.released += time * valves.get(v2)!!.flow_rate()
                    }
                    node.open_valves.push(node.current!)
                    node.just_opened = node.current!
                    ret.push(node)
                }
            } else if this.minutes_left_e > 0 {
                // pick another one for us, elephant is still on route
                let s_e = this.current_e!
                mut time_e = this.minutes_left_e
                let valve = valves.get(this.current!)!!
                for (s, i) in valve.neighbours() {
                    if s == s_e { continue }
                    if s == this.current! { continue }
                    if this.open_valves.contains(s) { continue }
                    if valves.get(s)!!.flow_rate() == 0 { continue }
                    time_e = this.minutes_left_e
                    mut time = i + 1 // travel time + open time
                    mut node = this.clone()
                    node.current = s
                    if time_e > time {
                        // we can get all the way to our valve, the elephant won't
                        time_e -= time
                        node.minutes += time
                        node.minutes_left = 0
                        node.minutes_left_e = time_e // set time remaining for elephant
                        for v2 in node.open_valves {
                            node.released += time * valves.get(v2)!!.flow_rate()
                        }
                        // open it
                        node.open_valves.push(node.current!)
                        node.just_opened = node.current!
                        ret.push(node)
                    } else {
                        // we either get to our goal at same time as elephant, or elephant beats us
                        time -= time_e
                        node.minutes += time_e
                        node.minutes_left = time // this may be 0 if we get there at same time
                        node.minutes_left_e = 0
                        for v2 in node.open_valves {
                            node.released += time_e * valves.get(v2)!!.flow_rate()
                        }
                        // open it
                        if time == 0 {
                            node.open_valves.push(node.current!)
                            node.just_opened = node.current!
                        }
                        node.open_valves.push(node.current_e!)
                        node.just_opened_e = node.current_e!
                        ret.push(node)
                    }
                }
                if ret.size() == 0 {
                    mut node = this.clone()
                    time_e = this.minutes_left_e
                    if time_e > this.minutes_remaining() {
                        // should be unreachable with check above
                        eprintln("unreachable time_e > this.minutes_remaining() ({} > {}) - {}", time_e, this.minutes_remaining(), this)
                        return ret
                    }
                    node.minutes += time_e
                    node.minutes_left_e = 0
                    for v2 in node.open_valves {
                        node.released += time_e * valves.get(v2)!!.flow_rate()
                    }
                    node.open_valves.push(node.current_e!)
                    node.just_opened_e = node.current_e!
                    ret.push(node)
                }
            } else {
                // both us and the elephant need to start moving
                // will need to find the min
                let valve = valves.get(this.current!)!!
                mut possibles: [String] = []
                for (s, i) in valve.neighbours() {
                    if s == this.current! { continue }
                    if this.open_valves.contains(s) { continue }
                    if valves.get(s)!!.flow_rate() == 0 { continue }
                    let time = i + 1 // travel time + open time
                    if time > this.minutes_remaining() {
                        // takes too long
                        continue
                    }
                    possibles.push(s)
                }
                for (s, i) in valve.neighbours() {
                    if s == this.current! { continue }
                    if this.open_valves.contains(s) { continue }
                    if valves.get(s)!!.flow_rate() == 0 { continue }
                    mut time = i + 1 // travel time + open time
                    if time > this.minutes_remaining() {
                        // takes too long
                        continue
                    }
                    let valve_e = valves.get(this.current_e!)!!
                    for (s_e, i_e) in valve_e.neighbours() {
                        if possibles.size() > 1 and s == s_e { continue }
                        if s_e == this.current_e! { continue }
                        if this.open_valves.contains(s_e) { continue }
                        if valves.get(s_e)!!.flow_rate() == 0 { continue }
                        time = i + 1 // travel time + open time
                        mut time_e = i_e + 1 // travel time + open time
                        if time_e > this.minutes_remaining() {
                            // takes too long
                            continue
                        }
                        mut node = this.clone()
                        node.current = s
                        node.current_e = s_e
                        if time_e > time {
                            // we can get all the way to our valve, the elephant won't
                            time_e -= time
                            node.minutes += time
                            node.minutes_left = 0
                            node.minutes_left_e = time_e // set time remaining for elephant
                            for v2 in node.open_valves {
                                node.released += time * valves.get(v2)!!.flow_rate()
                            }
                            // open it
                            node.open_valves.push(node.current!)
                            node.just_opened = node.current!
                            ret.push(node)
                        } else {
                            // we either get to our goal at same time as elephant, or elephant beats us
                            time -= time_e
                            node.minutes += time_e
                            node.minutes_left = time // this may be 0 if we get there at same time
                            node.minutes_left_e = 0
                            for v2 in node.open_valves {
                                node.released += time_e * valves.get(v2)!!.flow_rate()
                            }
                            // open it
                            if time == 0 and s != s_e {
                                node.open_valves.push(node.current!)
                                node.just_opened = node.current!
                            }
                            node.open_valves.push(node.current_e!)
                            node.just_opened_e = node.current_e!
                            ret.push(node)
                        }
                    }
                }
            }
        } else {
            // move to a new valve for x min, then open it, ignore 0 rates and already open
            let valve = valves.get(this.current!)!!
            for (s, i) in valve.neighbours() {
                if s == this.current! { continue }
                if this.open_valves.contains(s) { continue }
                if valves.get(s)!!.flow_rate() == 0 { continue }
                mut time = i + 1 // travel time + open time
                if time > this.minutes_remaining() {
                    // takes too long
                    continue
                }
                mut node = this.clone()
                // move there, then open it
                node.minutes += time
                node.current = s
                for v2 in node.open_valves {
                    node.released += time * valves.get(v2)!!.flow_rate()
                }
                // open it
                node.open_valves.push(node.current!)
                node.just_opened = node.current!
                ret.push(node)
            }
        }
        // if we don't have neighbours, just stay put and wait
        if ret.size() == 0 {
            mut node = this.clone()
            let time = this.minutes_remaining()
            node.minutes += time
            for v2 in node.open_valves {
                node.released += time * valves.get(v2)!!.flow_rate()
            }
            ret.push(node)
        }
        return ret
    }

    function is_complete(this) -> bool {
        return this.minutes_remaining() == 0
    }

    function minutes_remaining(this) -> i64 {
        return 30 - this.minutes
    }

    function g(this, valves: [String: Valve?]) -> i64 {
        return this.max_possible_g(valves) - this.released
    }

    function max_possible_g(this, valves: [String: Valve?]) -> i64 {
        mut ret = 0
        for (s, v) in valves {
            ret += this.minutes * v!.flow_rate()
        }
        return ret
    }

    function h(this, valves: [String: Valve?]) -> i64 {
        return 0
    }
    function _h(this, valves: [String: Valve?]) -> i64 {
        mut ret = -this.max_possible_h(valves)
        for v in this.open_valves {
            mut time = this.minutes_remaining()
            if this.just_opened.has_value() and this.just_opened! == v {
                time --
            }
            ret -= time * valves.get(v)!!.flow_rate()
        }
        return ret
    }

    function max_possible_h(this, valves: [String: Valve?]) -> i64 {
        if this.minutes_remaining() == 0 { return 0 }
        mut ret = 0
        let current = valves.get(this.current!)!!
        for (s, v) in valves {
            // this assumes that we will always travel from this node, but in reality we will go to one, then to another from there
            let distance = current.neighbours().get(s)!
            let time = this.minutes_remaining()// - 1 - distance
            ret += time * v!.flow_rate()
        }
        return ret
    }
}

function get_highest(open: Dictionary<String, Node>, fs: Dictionary<String, i64?>) -> String {
    // FIXME: Implement a min-heap or priority queue to reduce this
    // to O(log(n)). Currently it is O(n), n being around ?? for input
    // this is also run many times in the a_star function
    mut max_s: String? = None
    mut max: i64? = None
    for (s, n) in open {
        if not max.has_value() or fs[s]! > max! {
            max = fs[s]!
            max_s = s
        }
    }
    return max_s!
}

function get_lowest(anon open: Dictionary<String, Node>, anon fs: Dictionary<String, i64?>) -> String {
    // FIXME: Implement a min-heap or priority queue to reduce this
    // to O(log(n)). Currently it is O(n), n being around ?? for input
    // this is also run many times in the a_star function
    mut min_s: String? = None
    mut min: i64? = None
    for (s, n) in open {
        if not min.has_value() or fs[s]! < min! {
            min = fs[s]!
            min_s = s
        }
    }
    return min_s!
}
function get_lowest2(anon open: Dictionary<String, Valve?>, anon fs: Dictionary<String, i64?>) -> String {
    // FIXME: Implement a min-heap or priority queue to reduce this
    // to O(log(n)). Currently it is O(n), n being around ?? for input
    // this is also run many times in the a_star function
    mut min_s: String? = None
    mut min: i64? = None
    for (s, n) in open {
        if fs.contains(s) and (not min.has_value() or fs[s]! < min!) {
            min = fs[s]!
            min_s = s
        }
    }
    return min_s!
}
function a_star(valves: [String: Valve?], start: Node, elephant: bool = false) throws -> Node? {
    let start_str = format("{}", start)
    mut open: Dictionary<String, Node> = [start_str: start]
    mut gs = Dictionary<String, i64?>()
    gs[start_str] = start.g(valves)
    mut fs = Dictionary<String, i64?>()
    fs[start_str] = start.h(valves)
    while not open.is_empty() {
        let current_s = get_lowest(open, fs)
        let current = open.get(current_s)!
        if current.is_complete() {
            return current
        }
        open.remove(current_s)
        for n in current.neighbours(valves, elephant) {
            let n_s = format("{}", n)
            let g = n.g(valves)
            if not gs.contains(n_s) or g < gs[n_s]! {
                gs[n_s] = g
                fs[n_s] = g + n.h(valves)
                if not open.contains(n_s) {
                    open.set(n_s, n)
                }
            }
        }
    }
    return None
}

function dijkstra(mut valves: [String: Valve?]) throws {
    for (source_s, source_v) in valves {
        mut source = source_v
        mut q = Dictionary<String, Valve?>()
        mut dist = Dictionary<String, i64?>()
        for (v_s, v) in valves {
            q.set(v_s, v)
        }
        dist[source_s] = 0
        source!.set_distance(source_s, 0)

        while not q.is_empty() {
            let u_s = get_lowest2(q, dist)
            let u = q[u_s]!
            q.remove(u_s)
            for v_s in u.immediate_tunnels() {
                if not q.contains(v_s) { continue }
                let v = q[v_s]!
                let alt = dist[u_s]! + 1 // edge weight always 1 here
                if not dist.contains(v_s) or alt < dist[v_s]! {
                    dist[v_s] = alt
                    source!.set_distance(v_s, alt)
                }
            }
        }
    }
}

function main(args: [String]) {
    mut valves: [String: Valve?] = Dictionary<String, Valve?>()
    for line in read_lines(filename: "input") {
        let v = Valve::parse(valves, line)
    }
    dijkstra(valves)
//    for (s, v) in valves {
//        println("{}", s)
//        for (n, d) in v!.neighbours() {
//            println("  {} - {}", n, d)
//        }
//    }
    //if 1 == 1 { return 0 }
    let start = Node::start_node()
    mut max_node = a_star(valves, start)!
    println("Part 1: {}", max_node.released)
    max_node = a_star(valves, start, elephant: true)!
    println("Part 2: {}", max_node.released)
}
