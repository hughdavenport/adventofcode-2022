import helpers { read_lines, abs, min, max }

struct Point {
    x: i64
    y: i64

    function distance(this, anon p: Point) -> i64 {
        return abs(this.x-p.x)+abs(this.y-p.y)
    }
}

struct Sensor {
    sensor: Point
    beacon: Point

    function parse(anon s: String) throws -> Sensor {
        let split = s.split('=')
        let sensor = Point(
            x: split[1].split(',')[0].to_int()! as! i64,
            y: split[2].split(':')[0].to_int()! as! i64
        )
        let beacon = Point(
            x: split[3].split(',')[0].to_int()! as! i64,
            y: split[4].to_int()! as! i64
        )
        return Sensor(sensor, beacon)
    }

    function distance(this) -> i64 {
        return this.sensor.distance(this.beacon)
    }

    function bounds(this) -> Box {
        // works out bounds of the diamond surrounding the sensor
        let distance = this.distance()
        return Box(
            origin: Point(x: this.sensor.x - distance, y: this.sensor.y - distance),
            corner: Point(x: this.sensor.x + distance, y: this.sensor.y + distance)
        )
    }

}

struct Box {
    origin: Point
    corner: Point

    function adjust_bounds(mut this, anon p: Point) {
        if p.x < this.origin.x {
            this.origin.x = p.x
        }
        if p.y < this.origin.y {
            this.origin.y = p.y
        }
        if p.x > this.corner.x {
            this.corner.x = p.x
        }
        if p.y > this.corner.y {
            this.corner.y = p.y
        }
    }

    function adjust_bounds(mut this, anon b: Box) {
        this.adjust_bounds(b.origin)
        this.adjust_bounds(b.corner)
    }

    function size(this) -> usize {
        return this.width() * this.height()
    }

    function width(this) -> usize {
        return (this.corner.x - this.origin.x + 1) as! usize
    }

    function height(this) -> usize {
        return (this.corner.y - this.origin.y + 1) as! usize
    }

    function normalise(this, x: i64, y: i64) -> usize {
        let (_x, _y) = (
            (x - this.origin.x) as! usize,
            (y - this.origin.y) as! usize
        )
        return _y * this.width() + _x
    }
}

enum Thing {
    SENSOR
    BEACON
    UNAVAILABLE
    EMPTY

    function to_byte(this) -> u8 => match this {
        SENSOR => b'S'
        BEACON => b'B'
        UNAVAILABLE => b'#'
        EMPTY => b'.'
    }
}

function print_map(sensors: [Sensor]) throws {
    mut box: Box = Box(origin: sensors[0].sensor, corner: sensors[0].sensor)
    for s in sensors {
        box.adjust_bounds(s.bounds())
    }
    mut grid: [Thing] = [Thing::EMPTY(); box.size()]
    for s in sensors {
        grid[box.normalise(x: s.sensor.x, y: s.sensor.y)] = Thing::SENSOR()
        grid[box.normalise(x: s.beacon.x, y: s.beacon.y)] = Thing::BEACON()
    }
    for s in sensors {
        let distance = s.distance()
        let _x = s.sensor.x
        for y in (s.sensor.y-distance)..(s.sensor.y+distance+1) {
            let _y = distance - abs(y - s.sensor.y)
            for x in (_x-_y)..(_x+_y+1) {
                let idx = box.normalise(x, y)
                if grid[idx] is EMPTY() {
                    grid[idx] = Thing::UNAVAILABLE()
                }
            }
        }
    }
    for y in 0..box.height() {
        for x in 0..box.width() {
            print("{:c}", grid[y*box.width()+x].to_byte())
        }
        println()
    }
}

function main(args: [String]) {
    mut sensors: [Sensor] = []
    for line in read_lines(filename: "input") {
        sensors.push(Sensor::parse(line))
    }
    print_map(sensors)
}
